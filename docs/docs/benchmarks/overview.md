# Benchmarks

Metriq-Gym provides a comprehensive suite of quantum benchmarks to characterize and compare quantum hardware performance.

<!-- This file is auto-generated by scripts/generate_benchmark_docs.py -->
<!-- Do not edit manually. Instead, update docstrings and schemas. -->

## Running Benchmarks

### Dispatch a Benchmark

```bash
mgym job dispatch <config.json> --provider <provider> --device <device>
```

### Poll for Results

```bash
mgym job poll <JOB_ID>
```

## Configuration

All benchmarks use JSON configuration files validated against JSON schemas.

- **Example configurations**: [`metriq_gym/schemas/examples/`](https://github.com/unitaryfoundation/metriq-gym/tree/main/metriq_gym/schemas/examples)
- **JSON schemas**: [`metriq_gym/schemas/`](https://github.com/unitaryfoundation/metriq-gym/tree/main/metriq_gym/schemas)

## Available Benchmarks

### Quantum Volume

Quantum Volume benchmark implementation.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `num_qubits` | integer | Yes | — | Number of qubits in the Quantum Volume circuit(s). (min: 1) |
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) per circuit. (min: 1) |
| `trials` | integer | No | `100` | Number of random circuits to generate and measure for the Quantum Volume test. (min: 1) |
| `confidence_level` | number | No | `0.95` | Confidence level for establishing Quantum Volume success criteria. Must be between 0 and 1. (min: 0, max: 1) |

**Example configuration:**

```json
{
  "benchmark_name": "Quantum Volume",
  "num_qubits": 4,
  "shots": 2,
  "trials": 2,
  "confidence_level": 0.95
}
```

---

### CLOPS

The CLOPS benchmark schema definition, describing parameters for the CLOPS benchmark.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `width` | integer | No | `1000` | Circuit width, i.e., number of qubits or gates in one dimension. (min: 1) |
| `num_layers` | integer | No | `1000` | Number of repeated layers or blocks in the circuit. (min: 1) |
| `num_circuits` | integer | No | `100` | Number of circuits to generate and run for this benchmark. (min: 1) |
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) per circuit. (min: 1) |

**Example configuration:**

```json
{
  "benchmark_name": "CLOPS",
  "width": 4,
  "num_layers": 4,
  "num_circuits": 2,
  "shots": 10
}
```

---

### Mirror Circuits

Generates randomly parameterized mirror circuits that apply layers of Clifford gates, add a middle Pauli layer, and then revert the forward layers to test how well a device preserves state fidelity across the forward and reverse halves of the circuit.

**Result interpretation:**

Polling yields MirrorCircuitsResult with:
- success_probability: fraction of runs matching the expected bitstring.
- polarization: rescales success_probability to remove the uniform-random baseline;
higher implies better performance.
- binary_success: boolean indicating whether polarization exceeded 1/e.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `width` | integer | No | — | Number of qubits to use for the mirror circuit. If not specified, uses all available qubits on the device. (min: 2) |
| `num_layers` | integer | No | `3` | The number of random Clifford layers in the mirror circuit. This controls the circuit depth. (min: 1, max: 500) |
| `two_qubit_gate_prob` | number | No | `0.5` | Probability of applying a two-qubit gate on available edges. Must be between 0 and 1. (min: 0.0, max: 1.0) |
| `two_qubit_gate_name` | string | No | `CNOT` | Type of two-qubit gate to use in the circuit. |
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) for the benchmark. (min: 1) |
| `num_circuits` | integer | No | `10` | Number of random circuit repetitions for statistical averaging. Multiple circuits provide more robust statistical results. (min: 1, max: 1000) |
| `seed` | integer | No | — | Optional random seed for reproducible circuit generation. If provided, circuits will be deterministic. (min: 0) |

**Example configuration:**

```json
{
  "benchmark_name": "Mirror Circuits",
  "width": 4,
  "num_layers": 1,
  "two_qubit_gate_prob": 0.1,
  "shots": 1000,
  "num_circuits": 2
}
```

**References:**

- Proctor et al., "Measuring the capabilities of quantum computers", Nature Physics 18, 75-79 (2022).
- https://www.nature.com/articles/s41567-021-01409-7
- Phys. Rev. Lett. 129, 150502 (2022).
- https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.129.150502

---

### EPLG

Measures layer fidelity across qubit chains using randomized benchmarking techniques. Computes EPLG scores at various chain lengths to characterize two-qubit gate performance across the device.

**Result interpretation:**

Polling returns EPLGResult with:
- chain_lengths: list of qubit chain lengths tested
- chain_eplgs: EPLG values at each chain length
- eplg_10/20/50/100: EPLG at standard reference points
- score: average EPLG across reference points (lower is better)

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `num_qubits_in_chain` | integer | Yes | — | Number of qubits in the linear chain for layer fidelity measurement. (min: 4) |
| `lengths` | array | No | `[2, 4, 8, 16]` | Number of layers (circuit depths) in the randomized benchmarking protocol. |
| `num_samples` | integer | No | `3` | Number of random circuits sampled per depth in the randomized benchmarking protocol. (min: 1) |
| `shots` | integer | No | `100` | Number of measurement shots per circuit. (min: 1) |
| `seed` | integer | No | `12345` | Random seed for reproducibility. |
| `two_qubit_gate` | string | No | `cz` | Two-qubit gate to use. This should be a native entangling gate supported by the device. |
| `one_qubit_basis_gates` | array | No | `['rz', 'rx', 'x']` | Single-qubit basis gates for LayerFidelity experiment. This should complement the chosen two qubit gate to be a universal gateset |
| `decompose_clifford_ops` | boolean | No | `False` | Decompose the parameterized clifford operation types in the circuit to primitive operations; this may be necessary for providers that don't support Qiskit clifford primitives |

**Example configuration:**

```json
{
  "benchmark_name": "EPLG",
  "num_qubits_in_chain": 5,
  "lengths": [
    2,
    4
  ],
  "num_samples": 2,
  "shots": 100,
  "seed": 12345
}
```

**References:**

- McKay et al., "Benchmarking quantum processor performance at scale"
- https://arxiv.org/abs/2311.05933
- Based on qiskit-device-benchmarking layer fidelity notebook:
- https://github.com/qiskit-community/qiskit-device-benchmarking/blob/main/notebooks/layer_fidelity.ipynb

---

### BSEQ

Evaluates how well a device generates Bell pairs that violate the CHSH inequality across its connectivity graph. Circuits are built per colouring of the topology and executed in four measurement bases to detect correlations.

**Result interpretation:**

Polling returns BSEQResult with:
- largest_connected_size: size of the biggest connected subgraph of qubit pairs that
violated CHSH (> 2). Higher means entanglement spans more of the device.
- fraction_connected: largest_connected_size normalised by the discovered qubit count,
making it easier to compare devices of different sizes.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) to use for the benchmark. (min: 1) |
| `max_colors` | integer | No | — | If specified, Maximum number of colors to use in the BSEQ benchmark. If unspecified, all colors will be used. |

**Example configuration:**

```json
{
  "benchmark_name": "BSEQ",
  "shots": 1000
}
```

**References:**

- Original routines attributed to Paul Nation (Qiskit Device Benchmarking).
- J. F. Clauser et al., Phys. Rev. Lett. 23, 880 (1969).

---

### Wormhole-inspired teleportation (WIT)

Runs a six- or seven-qubit teleportation-inspired circuit that mimics the protocol from Shapoval et al. (2023) and reports a Pauli-Z expectation value with binomial uncertainty.

**Result interpretation:**

Polling returns WITResult.expectation_value as a BenchmarkScore:
- value: estimated Pauli-Z expectation (ideal teleportation trends toward +1).
- uncertainty: binomial standard deviation computed from the observed counts.
Compare value versus uncertainty to decide whether more shots are required or if noise is
degrading the teleportation fidelity.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) to use for the benchmark. (min: 1) |
| `num_qubits` | integer | No | `6` | Number of qubits to use for the benchmark. Must be either 6 or 7. |

**Example configuration:**

```json
{
  "benchmark_name": "WIT",
  "num_qubits": 7,
  "shots": 8192
}
```

**References:**

- I. Shapoval et al., "Towards Quantum Gravity in the Lab on Quantum Processors", Quantum 7,
- 1138 (2023), arXiv:2205.14081.
- Companion script: https://gitlab.com/ishapova/qglab/-/blob/master/scripts/wormhole.py.
- Implementation lineage credited to Paul Nation (IBM Quantum).

---

### LR-QAOA

Solves weighted Max-Cut instances with a linear-ramp parameter schedule and compares results against classical optima to estimate approximation ratios and optimal sampling probabilities.

**Result interpretation:**

Polling returns LinearRampQAOAResult with metrics including:
- approx_ratio_mean / stddev: how close average costs are to the optimum.
- optimal_probability_mean / stddev: frequency of sampling an optimal bitstring.
- confidence_pass: boolean indicating whether results meet the configured confidence.
Higher approximation ratios and optimal probabilities reflect better QAOA performance.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `graph_type` | string | Yes | — | Type of the graph, '1D':1D chain graph, 'NL': Native Layout graph, or 'FC': Fully connected graph. |
| `num_qubits` | integer | Yes | — | Number of qubits in the LR-QAOA circuit(s). (min: 2) |
| `qaoa_layers` | array | No | `[3, 5, 7, 10, 15, 20]` | List of the different layers depth of LR-QAOA. |
| `delta_beta` | number | No | `0.3` | Beta parameters slope in the linear function of LR-QAOA. (min: 0.0, max: 2.0) |
| `delta_gamma` | number | No | `0.3` | Gamma parameters slope in the linear function of LR-QAOA. (min: 0.0, max: 2.0) |
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) per circuit. (min: 1) |
| `trials` | integer | No | `3` | Number of circuits to generate and measure for the LR-QAOA test. (min: 1) |
| `num_random_trials` | integer | No | `25` | Number of circuits to generate and measure for the LR-QAOA test. (min: 10) |
| `confidence_level` | number | No | `0.995` | Confidence level for establishing LR-QAOA success criteria. Must be between 0 and 1. (min: 0.0, max: 1.0) |
| `seed` | integer | No | `123` | Seed to create the random weights of the weighted maxcut problem. This problem is solve using LR-QAOA |

**References:**

- Wurtz and Love, arXiv:2106.15645 (Linear-ramp QAOA parameter schedule)
- arXiv:2405.09169 (Additional LR-QAOA methodology)

---

### QML Kernel

Constructs a ZZ feature map kernel, computes the inner-product circuit, and measures the probability of returning to the all-zero state as a proxy for kernel quality.

**Result interpretation:**

Polling returns QMLKernelResult.accuracy_score as a BenchmarkScore where:
- value: fraction of shots measuring the expected all-zero bitstring.
- uncertainty: binomial standard deviation from the sample counts.
Higher accuracy suggests better kernel reproducibility on the selected hardware.
Reference:
- Inspired by ZZ-feature map approaches, e.g., arXiv:2405.09724.

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `num_qubits` | integer | Yes | — | Number of qubits used in the QML Kernel circuit(s). (min: 2) |
| `shots` | integer | No | `1000` | Number of measurement shots (repetitions) for the QML Kernel benchmark. (min: 1) |

**Example configuration:**

```json
{
  "benchmark_name": "QML Kernel",
  "num_qubits": 50,
  "shots": 1000
}
```


## Additional Benchmarks

The following benchmarks from the [QEDC benchmark suite](https://github.com/SRI-International/QC-App-Oriented-Benchmarks) are also available:

- Bernstein-Vazirani
- Phase Estimation
- Hidden Shift
- Quantum Fourier Transform

See their schema files in `metriq_gym/schemas/` for configuration options.

## Adding Custom Benchmarks

See [Adding New Benchmarks](../development/adding-benchmarks.md) to contribute new benchmarks.
